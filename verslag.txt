We hebben de Trie datastructure en ConcurrentQueue gebruikt. De Trie is non-blocking met Interlocked functies (CompareExchange), en de ConcurrentQueue is volgens msdn ook non-blocking met Interlocked functies. 
De voornaamste bottleneck in onze submission is de sync stap na ieder depth level. We starten hier gecentraliseerd nieuwe workers (via ThreadPool), en testen of de executie klaar is (gecentraliseerde ManualResetEvent). Hiermee garanderen we dat een dure state (met veel branches) niet gaat achterlopen op andere states van een nieuwer depth level, wat wel zou gebeuren als alle nieuwe states gelijk enqueued zouden worden. De A* gebruikt ook deze sync, maar pakt alleen de huidige beste states om te testen, en negeert voorlopig* alle minder goed beoordeelde states. *Voorlopig, omdat als de huidig beste oplossingen toch niet tot oplossingen komen, ze toch nog wel aan de beurt komen.